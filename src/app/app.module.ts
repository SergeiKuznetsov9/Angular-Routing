import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';

// Этот декоратор применяется к пустому классу
@NgModule({
  // Массив компонентов и дирректив, которые объявлены в данном модуле.
  // Для AppModule зачастую - это всего один компонент - AppComponent,
  // но бывают исключения
  declarations: [
    AppComponent
  ],

  // Принимает набор модулей, чьи экспорты будут доступны для шаблонов этого модуля
  // Так, например, AppRoutingModule экпортирует RouterModule, в результате чего он
  // его импорт доступен здесь
  imports: [
    BrowserModule,
    AppRoutingModule
  ],

  // массив инжектируемых объектов, которые будут доступны в инжекторе модуля 
  providers: [],

  // по дефолту он не объявлен. Здесь указывается набор компонент, дирректив и модулей
  // объявленных в данном конкретном модуле, но которые можно использовать в шаблоне любого компонента,
  // являющегося его частью.

  // Т.е., если модуль А добавить в импорты модуля Б, то если что то заэкспортировано в модуле А,
  // мы сможем пользоваться этим в модуле Б

  // Это нужно по той причине, что, к примеру, дирретивы мы не можем поместить в declarations одновременно
  // двух модулей
  exports: [],

  // Есть только у главного модуля - это комопнента, с которой начинается работа всего приложения
  // то что будет вставлено в index.html
  bootstrap: [AppComponent]
})
export class AppModule { }
